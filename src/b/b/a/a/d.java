// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/kpdus/jad.html
// Decompiler options: braces fieldsfirst space lnc 

package b.b.a.a;

import java.io.Reader;

// Referenced classes of package b.b.a.a:
//            e, c

class d
{

    private static final int a[] = {
        0, 0, 1, 1
    };
    private static final char b[] = a("\t\000\001\007\001\007\002\000\001\007\022\000\001\007\001\000\001\t\b\000\001\006\001\031\001\002\001\004\001\n\n\003\001\032\006\000\004\001\001\005\001\001\024\000\001\027\001\b\001\030\003\000\001\022\001\013\002\001\001\021\001\f\005\000\001\023\001\000\001\r\003\000\001\016\001\024\001\017\001\020\005\000\001\025\001\000\001\026\uFF82\0");
    private static final int c[] = d();
    private static final int d[] = e();
    private static final int e[] = {
        2, 2, 3, 4, 2, 2, 2, 5, 2, 6, 
        2, 2, 7, 8, 2, 9, 2, 2, 2, 2, 
        2, 10, 11, 12, 13, 14, 15, 16, 16, 16, 
        16, 16, 16, 16, 16, 17, 18, 16, 16, 16, 
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
        16, 16, 16, 16, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 4, 19, 20, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        21, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        23, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 16, 16, 16, 16, 16, 16, 16, 
        16, -1, -1, 16, 16, 16, 16, 16, 16, 16, 
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
        -1, -1, -1, -1, -1, -1, -1, -1, 24, 25, 
        26, 27, 28, 29, 30, 31, 32, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        33, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, 34, 35, -1, -1, 
        34, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        36, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 39, -1, 39, -1, 39, -1, -1, 
        -1, -1, -1, 39, 39, -1, -1, -1, -1, 39, 
        39, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, 33, -1, 20, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 35, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, 41, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, 42, -1, 42, -1, 42, 
        -1, -1, -1, -1, -1, 42, 42, -1, -1, -1, 
        -1, 42, 42, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, 43, -1, 43, -1, 43, -1, -1, -1, 
        -1, -1, 43, 43, -1, -1, -1, -1, 43, 43, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, 
        -1, 44, -1, 44, -1, -1, -1, -1, -1, 44, 
        44, -1, -1, -1, -1, 44, 44, -1, -1, -1, 
        -1, -1, -1, -1, -1
    };
    private static final String f[] = {
        "Unkown internal scanner error", "Error: could not match input", "Error: pushback value was too large"
    };
    private static final int g[] = f();
    private Reader h;
    private int i;
    private int j;
    private char k[];
    private int l;
    private int m;
    private int n;
    private int o;
    private int p;
    private int q;
    private int r;
    private boolean s;
    private boolean t;
    private StringBuffer u;

    d(Reader reader)
    {
        j = 0;
        k = new char[16384];
        s = true;
        u = new StringBuffer();
        h = reader;
    }

    private static int a(String s1, int i1, int ai[])
    {
        int j1;
        int k1;
        int l1;
        j1 = 0;
        k1 = s1.length();
        l1 = i1;
_L2:
        int j2;
        int k2;
        char c1;
        if (j1 >= k1)
        {
            break; /* Loop/switch isn't completed */
        }
        int i2 = j1 + 1;
        j2 = s1.charAt(j1);
        k2 = i2 + 1;
        c1 = s1.charAt(i2);
_L3:
        int l2;
        l2 = l1 + 1;
        ai[l1] = c1;
        if (--j2 > 0)
        {
            break MISSING_BLOCK_LABEL_76;
        }
        l1 = l2;
        j1 = k2;
        if (true) goto _L2; else goto _L1
_L1:
        return l1;
        l1 = l2;
          goto _L3
    }

    private static char[] a(String s1)
    {
        int i1;
        char ac[];
        int j1;
        i1 = 0;
        ac = new char[0x10000];
        j1 = 0;
_L2:
        int l1;
        int i2;
        char c1;
        if (j1 >= 90)
        {
            break; /* Loop/switch isn't completed */
        }
        int k1 = j1 + 1;
        l1 = s1.charAt(j1);
        i2 = k1 + 1;
        c1 = s1.charAt(k1);
_L3:
        int j2;
        j2 = i1 + 1;
        ac[i1] = c1;
        if (--l1 > 0)
        {
            break MISSING_BLOCK_LABEL_70;
        }
        i1 = j2;
        j1 = i2;
        if (true) goto _L2; else goto _L1
_L1:
        return ac;
        i1 = j2;
          goto _L3
    }

    private static int b(String s1, int i1, int ai[])
    {
        int j1 = 0;
        int k2;
        for (int k1 = s1.length(); j1 < k1; j1 = k2)
        {
            int l1 = j1 + 1;
            int i2 = s1.charAt(j1) << 16;
            int j2 = i1 + 1;
            k2 = l1 + 1;
            ai[i1] = i2 | s1.charAt(l1);
            i1 = j2;
        }

        return i1;
    }

    private static int c(String s1, int i1, int ai[])
    {
        int j1;
        int k1;
        int l1;
        j1 = 0;
        k1 = s1.length();
        l1 = i1;
_L2:
        int j2;
        int k2;
        char c1;
        if (j1 >= k1)
        {
            break; /* Loop/switch isn't completed */
        }
        int i2 = j1 + 1;
        j2 = s1.charAt(j1);
        k2 = i2 + 1;
        c1 = s1.charAt(i2);
_L3:
        int l2;
        l2 = l1 + 1;
        ai[l1] = c1;
        if (--j2 > 0)
        {
            break MISSING_BLOCK_LABEL_76;
        }
        l1 = l2;
        j1 = k2;
        if (true) goto _L2; else goto _L1
_L1:
        return l1;
        l1 = l2;
          goto _L3
    }

    private void c(int i1)
    {
        String s1;
        try
        {
            s1 = f[i1];
        }
        catch (ArrayIndexOutOfBoundsException arrayindexoutofboundsexception)
        {
            s1 = f[0];
        }
        throw new Error(s1);
    }

    private static int[] d()
    {
        int ai[] = new int[45];
        a("\002\000\002\001\001\002\001\003\001\004\003\001\001\005\001\006\001\007\001\b\001\t\001\n\001\013\001\f\001\r\005\000\001\f\001\016\001\017\001\020\001\021\001\022\001\023\001\024\001\000\001\025\001\000\001\025\004\000\001\026\001\027\002\000\001\030", 0, ai);
        return ai;
    }

    private static int[] e()
    {
        int ai[] = new int[45];
        b("\000\000\000\033\0006\000Q\000l\000\207\0006\000\242\000\275\000\330\0006\0006\0006\0006\0006\0006\000\363\000\u010E\0006\000\u0129\000\u0144\000\u015F\000\u017A\000\u0195\0006\0006\0006\0006\0006\0006\0006\0006\000\u01B0\000\u01CB\000\u01E6\000\u01E6\000\u0201\000\u021C\000\u0237\000\u0252\0006\0006\000\u026D\000\u0288\0006", 0, ai);
        return ai;
    }

    private static int[] f()
    {
        int ai[] = new int[45];
        c("\002\000\001\t\003\001\001\t\003\001\006\t\002\001\001\t\005\000\b\t\001\000\001\001\001\000\001\001\004\000\002\t\002\000\001\t", 0, ai);
        return ai;
    }

    private boolean g()
    {
        if (n > 0)
        {
            System.arraycopy(k, n, k, 0, o - n);
            o = o - n;
            m = m - n;
            l = l - n;
            n = 0;
        }
        if (m >= k.length)
        {
            char ac1[] = new char[2 * m];
            System.arraycopy(k, 0, ac1, 0, k.length);
            k = ac1;
        }
        int i1 = h.read(k, o, k.length - o);
        if (i1 > 0)
        {
            o = i1 + o;
            return false;
        }
        if (i1 == 0)
        {
            int j1 = h.read();
            if (j1 == -1)
            {
                return true;
            } else
            {
                char ac[] = k;
                int k1 = o;
                o = k1 + 1;
                ac[k1] = (char)j1;
                return false;
            }
        } else
        {
            return true;
        }
    }

    int a()
    {
        return q;
    }

    public final void a(int i1)
    {
        j = i1;
    }

    public final void a(Reader reader)
    {
        h = reader;
        s = true;
        t = false;
        n = 0;
        o = 0;
        l = 0;
        m = 0;
        r = 0;
        q = 0;
        p = 0;
        j = 0;
    }

    public final char b(int i1)
    {
        return k[i1 + n];
    }

    public final String b()
    {
        return new String(k, n, l - n);
    }

    public e c()
    {
        int i1;
        char ac[];
        char ac1[];
        int ai[];
        int ai1[];
        int ai2[];
        i1 = o;
        ac = k;
        ac1 = b;
        ai = e;
        ai1 = d;
        ai2 = g;
_L12:
        int j1;
        int k1;
        int l1;
        j1 = l;
        q = q + (j1 - n);
        k1 = -1;
        n = j1;
        m = j1;
        i = a[j];
        l1 = j1;
_L10:
        if (l1 >= i1) goto _L2; else goto _L1
_L1:
        int j2;
        char c1;
        j2 = l1 + 1;
        c1 = ac[l1];
_L4:
        int k2 = ai[ai1[i] + ac1[c1]];
        boolean flag;
        int i2;
        if (k2 != -1)
        {
label0:
            {
                i = k2;
                int l2 = ai2[i];
                if ((l2 & 1) != 1)
                {
                    break; /* Loop/switch isn't completed */
                }
                j3 = i;
                if ((l2 & 8) != 8)
                {
                    break label0;
                }
                k1 = j3;
                j1 = j2;
            }
        }
_L3:
        int i3;
        l = j1;
        if (k1 >= 0)
        {
            k1 = c[k1];
        }
        switch (k1)
        {
        default:
            int j3;
            Exception exception;
            int k3;
            if (c1 == '\uFFFF' && n == m)
            {
                t = true;
                return null;
            }
            c(1);
            break;

        case 11: // '\013'
            u.append(b());
            break;

        case 4: // '\004'
            u.delete(0, u.length());
            a(2);
            break;

        case 16: // '\020'
            u.append('\b');
            break;

        case 6: // '\006'
            return new e(2, null);

        case 23: // '\027'
            return new e(0, Boolean.valueOf(b()));

        case 22: // '\026'
            return new e(0, null);

        case 13: // '\r'
            a(0);
            return new e(0, u.toString());

        case 12: // '\f'
            u.append('\\');
            break;

        case 21: // '\025'
            return new e(0, Double.valueOf(b()));

        case 1: // '\001'
            throw new c(q, 0, new Character(b(0)));

        case 8: // '\b'
            return new e(4, null);

        case 19: // '\023'
            u.append('\r');
            break;

        case 15: // '\017'
            u.append('/');
            break;

        case 10: // '\n'
            return new e(6, null);

        case 14: // '\016'
            u.append('"');
            break;

        case 5: // '\005'
            return new e(1, null);

        case 17: // '\021'
            u.append('\f');
            break;

        case 24: // '\030'
            try
            {
                k3 = Integer.parseInt(b().substring(2), 16);
                u.append((char)k3);
            }
            // Misplaced declaration of an exception variable
            catch (Exception exception)
            {
                throw new c(q, 2, exception);
            }
            break;

        case 20: // '\024'
            u.append('\t');
            break;

        case 7: // '\007'
            return new e(3, null);

        case 2: // '\002'
            return new e(0, Long.valueOf(b()));

        case 18: // '\022'
            u.append('\n');
            break;

        case 9: // '\t'
            return new e(5, null);

        case 3: // '\003'
        case 25: // '\031'
        case 26: // '\032'
        case 27: // '\033'
        case 28: // '\034'
        case 29: // '\035'
        case 30: // '\036'
        case 31: // '\037'
        case 32: // ' '
        case 33: // '!'
        case 34: // '"'
        case 35: // '#'
        case 36: // '$'
        case 37: // '%'
        case 38: // '&'
        case 39: // '\''
        case 40: // '('
        case 41: // ')'
        case 42: // '*'
        case 43: // '+'
        case 44: // ','
        case 45: // '-'
        case 46: // '.'
        case 47: // '/'
        case 48: // '0'
            break;
        }
        continue; /* Loop/switch isn't completed */
_L2:
        if (t)
        {
            c1 = '\uFFFF';
        } else
        {
label1:
            {
                m = l1;
                l = j1;
                flag = g();
                i2 = m;
                j1 = l;
                ac = k;
                i1 = o;
                if (!flag)
                {
                    break label1;
                }
                c1 = '\uFFFF';
            }
        }
          goto _L3
        j2 = i2 + 1;
        c1 = ac[i2];
          goto _L4
        i3 = j3;
        j1 = j2;
_L8:
        k1 = i3;
        l1 = j2;
        if (true) goto _L6; else goto _L5
_L6:
        break; /* Loop/switch isn't completed */
_L5:
        i3 = k1;
        if (true) goto _L8; else goto _L7
_L7:
        if (true) goto _L10; else goto _L9
_L9:
        if (true) goto _L12; else goto _L11
_L11:
    }

}
